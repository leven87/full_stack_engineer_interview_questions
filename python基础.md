
### Python
* 装饰器   
  装饰器本质上是一个Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。 有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。 概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 参考： https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584  
 
* Python可变对象和不可变对象   
  这个问题比较tricky。 可变对象，包括list和dictionary,对象本身可变，但它对应的引用是不可变的。 不可变对象，包括int,string等，对象本身不可变，对象的内容是可变的。

* 进程和线程的区别 
  线程间可以共享数据，进程比线程更消耗资源，线程挂掉会导致进程挂掉，多个线程间会产生死锁。

* *args,**kwargs的区别  
  *args为多个无名参数，**kwargs为多个关键词参数。可参考：https://zhuanlan.zhihu.com/p/61683330 。

* 垃圾回收 
  Python的垃圾回收机制以引用计数为主， 标记清除、分代回收为辅。引用计数指：Python在内部维护了针对每一个对象的引用计数， 当一个对象创建或者被引用时，其引用计数将加1，当一个对象被销毁或作用域失效时， 其引用计数将减1。只有对象的引用计数为0时，这个对象将会被回收。引用计数的优点：简单、具有实时性。 缺点：对象循环引用时将永远不会被销毁。对于对象循环引用的状况Python使用标记清除来解决，Python在内部实现了一个循环检测器， 不停的检测对象是否存在循环引用，如果两个对象互相循环引用并且不包含其他第三者对象时， 其将会被收回。在Python参考手册中有写道：当一个对象无法获取时， 那么这个对象有可能被当成垃圾销毁了。Python将所有对象分成了三代， 对象存活时间越长就越晚被回收， 反之则越早被回收。

* 内存管理 
  Python使用了内存池机制来管理内存，其内存以金字塔的形式对内存功能进行划分，-1、-2层主要用于对操作系统进行操作， 0层中是C的malloc,、free等等内存分配和释放函数。1、2层是一个内存池， 当对象小于265K时将直接由这片内存池进行分配内存，否则将调用第0层中的C函数来分配内存，当小于265K的对象被销毁时， 其内存也不会被销毁， 只是返回给了内存池以便二次利用。2层是对Python对象进行操作。

* 多线程 
  python 在IO密集型情况下，表现较好；在CPU密集型情况下，由于GIL无法释放，表现反而不如单线程。

* os与sys模块不同
  os: 提供了对使用操作系统函数的高度封装，如：os.getcwd() #获取当前运行路径。sys: 提供与解释器交互的相关函数， 如：sys.modules # 系统导入的模块名称， sys.stdin # 标准输入。

* lambda表达式 
  lambda也是函数的一种， 在处理一些简单的操作时可以使用该表达式， 其好处是不用为一些实现简单功能的函数命名。省去了命名的苦恼。 如： g = lambda x:x+1 ，则 g(1) = 2。

* Python中拷贝对象 
  Python中拷贝分为深拷贝、浅拷贝。浅拷贝只拷贝父级对象， 不会拷贝对象内部的子对象，使用copy模块中的copy。深拷贝则会完全拷贝父对象以及子对象， 使用copy模块中的deepcopy

* __new__和__init__的区别 
  __new__负责构建一个类对象并将其返回，__init__则负责初始化一些变量，不返回任何对象。在实例化一个类时， __new__方法将会先被运行， 其次才运行__init__方法

* 并发和并行 
  并发只是在宏观上给人感觉有多个程序在同时运行，但在实际的单CPU系统中，每一时刻只有一个程序在运行，微观上这些程序是分时交替执行。 并行则不同，在多CPU系统中，将这些并发执行的程序分配到不同的CPU上处理，每个CPU用来处理一个程序，这样多个程序便可以实现同时执行。

* 进程，线程和协程的关系。 
  参看： https://zhuanlan.zhihu.com/p/70256971 协程是一种用户态的轻量级线程。 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。协程与线程非常相似。 但是，协程是协作式多任务的，而线程通常是抢先式多任务的。 这意味着协程提供并发性，但不提供并行性。

* 异常机制 
  Python中异常也是一个对象， 所有的异常的基类都是Exception。捕获异常使用try...except....语法，如果要try与except之间的代码出现了错误并且我们将其异常类型捕获了那么代码将会跳转代except中去执行。还可以使用raise 去手动的触发一个错误。

* classmethod，staticmethod，property是什么？有什么作用？  
  classmethod，staticmethod，property都是装饰器， 他们都作用在类的方法上。  
  classmethod：使得被装饰的方法成为一个类方法既不需要实例化类就可以直接调用的方法，第一个参数为cls。  
  staticmethod： 使得被装饰的方法成为一个静态函数既与普通的函数无区别。  
  property: 将一个方法变成一个属性来使用。 
  
* python中的绑定方法和未绑定方法是什么？  
  绑定方法：绑定了实例化的方法既第一个参数是self。未绑定方法：没有绑定实例化的方法，即类方法、静态方法  
  
* python上下文管理器和with 
  Python中上下文管理器使用with来调用主要用于数据库连接，文件操作， 网络操作。  
  其作用是： 如果在进行一些打开资源操作时出现了异常，上下文管理器将会自动的执行一些资源清理操作。 
  参看： https://zhuanlan.zhihu.com/p/24709718
  
* functools的wraps是做什么的？ 
  wraps是一个装饰器功能是： 由于被装饰的函数传入到装饰器中时已经不是原函数了， 而是一个新的函数， 并且丢失一些原函数的属性， 为了不影响函数的使用， 可以使用wraps来抵消这种副作用。参见：https://www.jianshu.com/p/a76f1409c349
  
* python的ORM
  ORM（Object Relational Mapping）即对象关系映射，主要用于将对象映射成SQL语句。通过python中的属性描述符协议实现， 在给这个属性进行赋值时（对应数据库中的字段名称）会调用__set__方法，访问  属性则会调用__get__方法删除则调用__delete__方法。
  
* 生成器和迭代器的区别
  生成器时一种特殊的迭代器， 生成器自动实现了迭代器协议， 不需要手动的实现__iter__以及next方法，生成器在迭代的过程中可以改变当前的迭代值， 而普通的迭代器改变当前值时往往会发生错。迭代器必须实现__iter__以及next方法。
  
* type的作用
  当type只传入一个参数时将返回该参数的类型，如果传入了三个参数则返回一个类对象
  
* 列表和元组的区别
  相同：列表和元组都是容器且是可迭代对象，二者可以包含任意类型的对象。
  不同：列表是可变类型，元组是不可变类型。
  
* list如何实现的?
  底层是C语言的结构体，它采用动态分配内存。即过度分配内存以避免调用list_resize太多时间， 列表的增长方式为：0、4、8、16、25、35、46、58、72、88。 参看: https://zhuanlan.zhihu.com/p/143223943

* list索引查询的时间复杂度。
  O(1)。 对于一块连续的存储空间，获取某个位置的地址通过一步计算即可算出。通常的公式是i_addr = start_addr + i * unit_byte.
  
* python字典的实现原理
  哈希表。 添加数据时，key会通过哈希函数转化为一个数字，然后将该数字对存放value的数组长度取余,并将取余结果当做数组的下标。
  
* 什么是pickling和unpickling？
  本质上就是序列化。 Pickle模块读入任何Python对象，将它们转换成字符串，然后使用dump函数将其转储到一个文件中——这个过程叫做pickling，反之从存储的字符串文件中提取原始Python对象的过程，叫做unpickling。  

* python中debug和静态分析的工具？
  * PyChecker是一个静态分析工具，它不仅能报告源代码中的错误，并且会报告错误类型和复杂度。
  * Pylint 代码给是检测工具。
  * dis用来查看python对象的字节码。
  * PySnooper。 只需为要调试的函数添加一个装饰器即可，而不需要构建正确的 print 打印。你还将得到函数的详细日志，包括运行了哪些代码行、何时运行以及何时更改了局部变量。 
  * IDE

* 写一个函数, 输入一个字符串, 返回倒序排列的结果
  ```python
  def reverse(text):
    return text[::-1]
  ```

* python中is和==的区别
  is比较的是对象在内存的地址， ==比较的对象中的值
  
* python的闭包是什么
  内层函数引用了其外部作用域的变量，然后返回内层函数的情况，称为闭包。闭包就是将函数内部和函数外部连接起来的一座桥梁。如：
  ```python
  def startAt(x):
      def add(y):
          return x+y
      return add
      
  a = startAt(1)
  print('function', a)
  print('result', a(1))
  ```
  其广泛应用于爬虫及web应用，参看： https://zhuanlan.zhihu.com/p/22229197
  
* python高并发的解决方案（同样也适用于其它语言）
  * 硬件方面
    * 容器技术，高峰时扩容
    * 硬件，升级网卡
    * DNS域名解析，更换域名服务器，加快解析速度
    * CDN加速 将静态内容，如图片，静态网页，视频等放到CDN上
  * 软件优化
    * 精灵图 多个图片转成一个张图，通过css的位移技术，展示到页面
    * mysql + redis 
    * 数据库的优化： sql优化，索引优化，分库分表，读写分离
    * django,flask等框架自带的缓存机制
    * celery处理异步任务。 Celery 是一个基于python开发的分布式异步消息任务队列，通过它可以轻松的实现任务的异步处理。 参见： https://www.cnblogs.com/alex3714/p/6351797.html   
       
* Python并发的框架选择
  * twisted 事件驱动型网络引擎，对于io密集型操作，有很好的性能，不需要关心线程锁的问题，可以很好解决数据共享问题。
  * tornado 是一个web框架，它自带有高性能网络库，可以处理高并发问题
  * gevent 基于协程的Python网络库
  * sanic 基于uvloop和httptools实现高并发异步网络框架
