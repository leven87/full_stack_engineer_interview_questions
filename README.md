# interview_questions
I feel really depressed when I took some interviews recently. They kept asking the basic and tricky questions when you could google it quite easily. But unfortunately, this is the rule. So I would summarize all pontential interview questions here to follow the rules(suck their fucking dicks).

---
### Python
* 装饰器 装饰器本质上是一个Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。 有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。 概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 参考： https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584  
 
* Python可变对象和不可变对象 这个问题比较tricky。 可变对象，包括list和dictionary,对象本身可变，但它对应的引用是不可变的。 不可变对象，包括int,string等，对象本身不可变，对象的内容是可变的。

* 进程和线程的区别 线程间可以共享数据，进程比线程更消耗资源，线程挂掉会导致进程挂掉，多个线程间会产生死锁。

* *args,**kwargs的区别  *args为多个无名参数，**kwargs为多个关键词参数。可参考：https://zhuanlan.zhihu.com/p/61683330 。

* 垃圾回收 Python的垃圾回收机制以引用计数为主， 标记清除、分代回收为辅。引用计数指：Python在内部维护了针对每一个对象的引用计数， 当一个对象创建或者被引用时，其引用计数将加1，当一个对象被销毁或作用域失效时， 其引用计数将减1。只有对象的引用计数为0时，这个对象将会被回收。引用计数的优点：简单、具有实时性。 缺点：对象循环引用时将永远不会被销毁。对于对象循环引用的状况Python使用标记清除来解决，Python在内部实现了一个循环检测器， 不停的检测对象是否存在循环引用，如果两个对象互相循环引用并且不包含其他第三者对象时， 其将会被收回。在Python参考手册中有写道：当一个对象无法获取时， 那么这个对象有可能被当成垃圾销毁了。Python将所有对象分成了三代， 对象存活时间越长就越晚被回收， 反之则越早被回收。

* 内存管理 Python使用了内存池机制来管理内存，其内存以金字塔的形式对内存功能进行划分，-1、-2层主要用于对操作系统进行操作， 0层中是C的malloc,、free等等内存分配和释放函数。1、2层是一个内存池， 当对象小于265K时将直接由这片内存池进行分配内存，否则将调用第0层中的C函数来分配内存，当小于265K的对象被销毁时， 其内存也不会被销毁， 只是返回给了内存池以便二次利用。2层是对Python对象进行操作。

* 多线程 python 在IO密集型情况下，表现较好；在CPU密集型情况下，由于GIL无法释放，表现反而不如单线程。

* os与sys模块不同。 os: 提供了对使用操作系统函数的高度封装，如：os.getcwd() #获取当前运行路径。sys: 提供与解释器交互的相关函数， 如：sys.modules # 系统导入的模块名称， sys.stdin # 标准输入。

* lambda表达式 lambda也是函数的一种， 在处理一些简单的操作时可以使用该表达式， 其好处是不用为一些实现简单功能的函数命名。省去了命名的苦恼。

* Python中拷贝对象 Python中拷贝分为深拷贝、浅拷贝。浅拷贝只拷贝父级对象， 不会拷贝对象内部的子对象，使用copy模块中的copy。深拷贝则会完全拷贝父对象以及子对象， 使用copy模块中的deepcopy

* __new__和__init__的区别 __new__负责构建一个类对象并将其返回，__init__则负责初始化一些变量，不返回任何对象。在实例化一个类时， __new__方法将会先被运行， 其次才运行__init__方法

* 并发和并行 并发只是在宏观上给人感觉有多个程序在同时运行，但在实际的单CPU系统中，每一时刻只有一个程序在运行，微观上这些程序是分时交替执行。 并行则不同，在多CPU系统中，将这些并发执行的程序分配到不同的CPU上处理，每个CPU用来处理一个程序，这样多个程序便可以实现同时执行。

* 进程，线程和协程的关系。 参看： https://zhuanlan.zhihu.com/p/70256971 协程是一种用户态的轻量级线程。 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。协程与线程非常相似。 但是，协程是协作式多任务的，而线程通常是抢先式多任务的。 这意味着协程提供并发性，但不提供并行性。

* 异常机制 Python中异常也是一个对象， 所有的异常的基类都是Exception。捕获异常使用try...except....语法，如果要try与except之间的代码出现了错误并且我们将其异常类型捕获了那么代码将会跳转代except中去执行。还可以使用raise 去手动的触发一个错误。

* classmethod，staticmethod，property是什么？有什么作用？  
  classmethod，staticmethod，property都是装饰器， 他们都作用在类的方法上。  
  classmethod：使得被装饰的方法成为一个类方法既不需要实例化类就可以直接调用的方法，第一个参数为cls。  
  staticmethod： 使得被装饰的方法成为一个静态函数既与普通的函数无区别。  
  property: 将一个方法变成一个属性来使用。
